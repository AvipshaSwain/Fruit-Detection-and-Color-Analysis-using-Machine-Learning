# -*- coding: utf-8 -*-
"""ML Case study

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bBuVpiO2eHdtYvDYkm-Ri17nbJ4aihpU

Mounting Google Drive

This cell mounts your Google Drive to the Colab environment, allowing you to access files stored there.
"""

from google.colab import drive
drive.mount('/content/drive')

"""Extracting the Archive

This cell extracts the contents of the 'archive (8).zip' file into a folder named 'extracted_archive' within your Colab environment.
"""

import zipfile

with zipfile.ZipFile('/content/archive (8).zip', 'r') as zip_ref:
    zip_ref.extractall('/content/extracted_archive')

"""Exploring the Extracted Archive

This cell lists the files and directories within the extracted archive and the 'Fruits-detection' folder. This helps you understand the structure of your data.
"""

import os
import zipfile

# Extract the archive
with zipfile.ZipFile('/content/archive (8).zip', 'r') as zip_ref:
    zip_ref.extractall('/content/extracted_archive')

# Path to the extracted archive
extracted_archive_path = '/content/extracted_archive'

# Path to the 'Fruits-detection' folder (if you want to list contents within it)
fruits_detection_path = os.path.join(extracted_archive_path, 'Fruits-detection')

# List files and directories in the extracted archive
print("Contents of extracted archive:")
for item in os.listdir(extracted_archive_path):
    item_path = os.path.join(extracted_archive_path, item)
    print(f"- {item}: {'Directory' if os.path.isdir(item_path) else 'File'}")

# List files and directories within 'Fruits-detection' (optional)
print("\nContents of Fruits-detection:")
for item in os.listdir(fruits_detection_path):
    item_path = os.path.join(fruits_detection_path, item)
    print(f"- {item}: {'Directory' if os.path.isdir(item_path) else 'File'}")

# You can now access files or directories within 'Fruits-detection'
# using their respective paths, e.g.,
# data_yaml_path = os.path.join(fruits_detection_path, 'data.yaml')
# with open(data_yaml_path, 'r') as f:
#     # Process data.yaml

"""Displaying Random Images

This cell displays a few random images from the training, testing, and validation sets of your dataset. This is useful for visualizing the data.
"""

import os
import random
from PIL import Image
import matplotlib.pyplot as plt

# Define paths to the train, test, and validation images directories
train_images_path = '/content/extracted_archive/Fruits-detection/train/images'
test_images_path = '/content/extracted_archive/Fruits-detection/test/images'
validation_images_path = '/content/extracted_archive/Fruits-detection/valid/images'

# Function to display random images from a specified directory
def display_random_images(image_dir, num_images=5, title="Images"):
    # List all images in the directory
    images = [img for img in os.listdir(image_dir) if img.endswith(('.png', '.jpg', '.jpeg'))]

    # Check if any images were found
    if not images:
        print(f"No images found in directory: {image_dir}")
        return

    # Randomly select a few images
    selected_images = random.sample(images, min(num_images, len(images)))

    # Display images
    fig, axes = plt.subplots(1, len(selected_images), figsize=(15, 15))
    for i, image_name in enumerate(selected_images):
        image_path = os.path.join(image_dir, image_name)
        img = Image.open(image_path)
        axes[i].imshow(img)
        axes[i].set_title(image_name)
        axes[i].axis('off')  # Hide axes for a cleaner look

    fig.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

# Display random images from each folder
display_random_images(train_images_path, title="Training Images")
display_random_images(test_images_path, title="Test Images")
display_random_images(validation_images_path, title="Validation Images")

"""Displaying Images with Labels

This cell displays random images along with their corresponding labels. This helps you verify that the images are correctly labeled.
"""

import os
import random
from PIL import Image
import matplotlib.pyplot as plt

# Define paths to the directories
train_images_path = '/content/extracted_archive/Fruits-detection/train/images'  # Added /images to the path
train_labels_path = '/content/extracted_archive/Fruits-detection/train/labels'
test_images_path = '/content/extracted_archive/Fruits-detection/test/images'   # Added /images to the path
test_labels_path = '/content/extracted_archive/Fruits-detection/test/labels'
validation_images_path = '/content/extracted_archive/Fruits-detection/valid/images' # Added /images to the path
validation_labels_path = '/content/extracted_archive/Fruits-detection/valid/labels'

# Function to read label from a corresponding file
def read_label(image_name, labels_path):
    label_file = os.path.splitext(image_name)[0] + '.txt'  # Assuming labels are .txt files
    label_path = os.path.join(labels_path, label_file)
    if os.path.exists(label_path):
        with open(label_path, 'r') as file:
            return file.read().strip()  # Read and return label
    return "No label found"  # Fallback if label not found

# Function to display random images with labels
def display_random_images_with_labels(image_dir, labels_path, num_images=5, dataset_name="Dataset"):
    images = [img for img in os.listdir(image_dir) if img.endswith(('.png', '.jpg', '.jpeg'))]

    # Check if any images were found before proceeding
    if not images:
        print(f"No images found in directory: {image_dir}")
        return

    # Randomly select a few images
    selected_images = random.sample(images, min(num_images, len(images)))

    # Display images
    fig, axes = plt.subplots(1, len(selected_images), figsize=(15, 15))
    fig.suptitle(dataset_name, fontsize=16)

    for i, image_name in enumerate(selected_images):
        image_path = os.path.join(image_dir, image_name)
        img = Image.open(image_path)

        # Read the corresponding label
        label = read_label(image_name, labels_path)

        axes[i].imshow(img)
        axes[i].set_title(label)  # Set label as title
        axes[i].axis('off')  # Hide axes for cleaner look

    plt.tight_layout()
    plt.show()

# Display random images with labels for each dataset
display_random_images_with_labels(train_images_path, train_labels_path, dataset_name="Training Images")
display_random_images_with_labels(test_images_path, test_labels_path, dataset_name="Test Images")
display_random_images_with_labels(validation_images_path, validation_labels_path, dataset_name="Validation Images")

"""Creating an Empty DataFrame

This cell creates an empty pandas DataFrame named 'df'. This DataFrame is likely intended to store data for further analysis.
"""

import os
import random
from PIL import Image
import matplotlib.pyplot as plt
import pandas as pd # Import pandas library

df = pd.DataFrame()

"""Handling Missing Values

This cell checks for missing values in the DataFrame 'df' and provides options for handling them, such as filling them with the mean or dropping rows with missing values.
"""

# Check for missing values
print("Missing values before preprocessing:\n", df.isnull().sum())

# Option 1: Fill missing values with the mean of each column
df.fillna(df.mean(), inplace=True)

# Option 2: Drop rows with missing values (use only if there are very few NaNs)
# df.dropna(inplace=True)

print("Missing values after preprocessing:\n", df.isnull().sum())

""" Extracting Color Features

This cell extracts color features (average RGB values) from the images in your dataset. These features can be used for further analysis or modeling.
"""

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from PIL import Image
import os  # Import the os module

# Using the provided paths
train_images_path = '/content/extracted_archive/Fruits-detection/train/images'
test_images_path = '/content/extracted_archive/Fruits-detection/test/images'
validation_images_path = '/content/extracted_archive/Fruits-detection/valid/images'

# Function to extract features from image paths
def extract_features(image_paths):
    features = []
    for image_path in image_paths:
        try:
            img = Image.open(image_path)
            pixels = np.array(img)
            avg_color = np.mean(pixels, axis=(0, 1))
            features.append(avg_color)
        except Exception as e:
            print(f"Error processing image {image_path}: {e}")
    return np.array(features)

# Create lists of image paths
train_image_paths = [os.path.join(train_images_path, filename) for filename in os.listdir(train_images_path) if filename.endswith(('.jpg', '.png', '.jpeg'))]
test_image_paths = [os.path.join(test_images_path, filename) for filename in os.listdir(test_images_path) if filename.endswith(('.jpg', '.png', '.jpeg'))]
validation_image_paths = [os.path.join(validation_images_path, filename) for filename in os.listdir(validation_images_path) if filename.endswith(('.jpg', '.png', '.jpeg'))]

# Print the number of images found in each directory
print("Number of training images found:", len(train_image_paths))
print("Number of testing images found:", len(test_image_paths))
print("Number of validation images found:", len(validation_image_paths))

# Extract features
train_features = extract_features(train_image_paths)
test_features = extract_features(test_image_paths)
validation_features = extract_features(validation_image_paths)

print("Train features shape:", train_features.shape)
print("Test features shape:", test_features.shape)
print("Validation features shape:", validation_features.shape)

"""Plotting Color Histograms

This cell defines a function plot_color_histograms to create histograms showing the distribution of RGB values for different labels (likely used for analysis).
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

# Ensure inline plotting for Jupyter Notebooks
# %matplotlib inline

def plot_color_histograms(features, labels):
    # Ensure labels array has the same length as the number of features
    if len(labels) == 0:  # Check if labels is empty
        num_features = features.shape[0]  # Get the number of features
        labels = np.zeros(num_features)  # Create an array of zeros with the same length

    # Convert features to a Pandas DataFrame for easier plotting
    df = pd.DataFrame(features, columns=['Red', 'Green', 'Blue'])
    df['Label'] = labels  # Add labels to the DataFrame

    # Define a custom color palette using pink and yellow
    custom_palette = ['#E08EAD', '#FFA500']  # Light pink and golden yellow

    # Create histograms for each color channel with the custom palette
    for color in ['Red', 'Green', 'Blue']:
        plt.figure(figsize=(8, 6))
        sns.histplot(data=df, x=color, hue='Label', kde=True, bins=30, palette=custom_palette)  # Set custom palette
        plt.title(f'Histogram of {color} Values')
        plt.xlabel(color)
        plt.ylabel('Frequency')
        plt.show()

# Example: Create some synthetic data (you should replace this with your actual data)
num_samples = 100
train_features = np.random.randint(0, 256, size=(num_samples, 3))  # Random RGB values
train_labels = np.random.randint(0, 2, size=num_samples)  # Random binary labels (0 or 1)

# Call the function to plot the histograms
plot_color_histograms(train_features, train_labels)

"""Correlation Heatmap

This cell calculates and visualizes the correlation between RGB channels using a heatmap. This is to analyze the relationship between color components.
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

# Example: Create some synthetic data (you should replace this with your actual data)
num_samples = 100
train_features = np.random.randint(0, 256, size=(num_samples, 3))  # Random RGB values
train_labels = np.random.randint(0, 2, size=num_samples)  # Random binary labels (0 or 1)

# Convert features to a Pandas DataFrame for easier processing
df = pd.DataFrame(train_features, columns=['Red', 'Green', 'Blue'])

# Calculate the correlation matrix
correlation_matrix = df.corr()

# Create a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', square=True, cbar=True)
plt.title('Correlation Heatmap of RGB Channels')
plt.show()

"""Scatter Plots of RGB Channels

This cell generates scatter plots to visualize the relationship between different pairs of RGB channels.
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

# Example: Create some synthetic data
num_samples = 100
train_features = np.random.randint(0, 256, size=(num_samples, 3))  # Random RGB values
train_labels = np.random.randint(0, 2, size=num_samples)  # Random binary labels (0 or 1)

# Convert features to a Pandas DataFrame
df = pd.DataFrame(train_features, columns=['Red', 'Green', 'Blue'])
df['Label'] = train_labels  # Add labels to the DataFrame

# Create a scatter plot matrix
plt.figure(figsize=(10, 10))
sns.scatterplot(data=df, x='Red', y='Green', hue='Label', style='Label', palette='dark')
plt.title('Scatter Plot of Red vs Green')
plt.xlabel('Red')
plt.ylabel('Green')
plt.show()

plt.figure(figsize=(10, 10))
sns.scatterplot(data=df, x='Red', y='Blue', hue='Label', style='Label', palette='dark')
plt.title('Scatter Plot of Red vs Blue')
plt.xlabel('Red')
plt.ylabel('Blue')
plt.show()

plt.figure(figsize=(10, 10))
sns.scatterplot(data=df, x='Green', y='Blue', hue='Label', style='Label', palette='dark')
plt.title('Scatter Plot of Green vs Blue')
plt.xlabel('Green')
plt.ylabel('Blue')
plt.show()

"""Box Plots of RGB Channels

This cell uses box plots to show the distribution of RGB values for different labels.
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

# Example: Create some synthetic data
num_samples = 100
train_features = np.random.randint(0, 256, size=(num_samples, 3))  # Random RGB values
train_labels = np.random.randint(0, 2, size=num_samples)  # Random binary labels (0 or 1)

# Convert features to a Pandas DataFrame
df = pd.DataFrame(train_features, columns=['Red', 'Green', 'Blue'])
df['Label'] = train_labels  # Add labels to the DataFrame

# Create box plots for each channel
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Label', y='Red', palette='dark')
plt.title('Box Plot of Red Channel by Label')
plt.show()

plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Label', y='Green', palette='dark')
plt.title('Box Plot of Green Channel by Label')
plt.show()

plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Label', y='Blue', palette='dark')
plt.title('Box Plot of Blue Channel by Label')
plt.show()

"""Preprocessing Images

This cell defines a function preprocess_images to extract color features and labels from images.
"""

import cv2
import numpy as np
import os

def extract_color_features(image_path):
    # Read and process the image
    img = cv2.imread(image_path)
    if img is None:
        print(f"Image not found or unreadable at path: {image_path}")
        return None
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    mean_color = cv2.mean(img)[:3]
    return mean_color

def preprocess_images(image_dir, labels_dir):
    features = []
    labels = []

    for img_name in os.listdir(image_dir):
        img_path = os.path.join(image_dir, img_name)
        label_path = os.path.join(labels_dir, os.path.splitext(img_name)[0] + '.txt')

        if img_name.endswith(('.png', '.jpg', '.jpeg')) and os.path.exists(label_path):
            feature = extract_color_features(img_path)
            if feature is not None:
                features.append(feature)
                with open(label_path, 'r') as f:
                    label = f.read().strip()
                labels.append(label)
        else:
            print(f"Skipped file or missing label: {img_name}")

    features = np.array(features)
    labels = np.array(labels)
    print("Features Loaded:", features.shape)
    print("Labels Loaded:", labels.shape)

    return features, labels

# Example Usage
train_images_path = '/content/extracted_archive/Fruits-detection/train/images'
train_labels_path = '/content/extracted_archive/Fruits-detection/train/labels'
X, y = preprocess_images(train_images_path, train_labels_path)

"""KNN Classification

This cell includes imports related to the KNN classifier.
"""

import cv2
import numpy as np
import os
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.model_selection import GridSearchCV

"""Training and Evaluating KNN

This cell loads data using the preprocessing functions, splits it into training and test sets, standardizes the features, trains a KNN classifier, and evaluates its performance.
"""

def extract_color_features(image_path):
    # Read and process the image
    img = cv2.imread(image_path)
    if img is None:
        print(f"Image not found or unreadable at path: {image_path}")
        return None
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    mean_color = cv2.mean(img)[:3]
    return mean_color

def preprocess_images(image_dir, labels_dir):
    features = []
    labels = []

    for img_name in os.listdir(image_dir):
        img_path = os.path.join(image_dir, img_name)
        label_path = os.path.join(labels_dir, os.path.splitext(img_name)[0] + '.txt')

        if img_name.endswith(('.png', '.jpg', '.jpeg')) and os.path.exists(label_path):
            feature = extract_color_features(img_path)
            if feature is not None:
                features.append(feature)
                with open(label_path, 'r') as f:
                    label = f.read().strip()
                labels.append(label)
        else:
            print(f"Skipped file or missing label: {img_name}")

    features = np.array(features)
    labels = np.array(labels)
    return features, labels

# Paths to your image and label directories
train_images_path = '/content/extracted_archive/Fruits-detection/train/images'
train_labels_path = '/content/extracted_archive/Fruits-detection/train/labels'

# Load the features and labels
X, y = preprocess_images(train_images_path, train_labels_path)
print("Shape of X:", X.shape)
print("Shape of y:", len(y))

# Check if X and y are empty
if X.size == 0 or len(y) == 0:
    print("Error: No data loaded into X or y. Please check the image paths and preprocessing function.")
else:
    # Proceed to split if data is present
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Standardize the features (mean=0, variance=1)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
print("X_train shape after standardization:", X_train.shape)
print("X_test shape after standardization:", X_test.shape)

# Initialize the KNN model
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train, y_train)

# Make predictions
y_pred = knn.predict(X_test)

# Evaluate the model
print("KNN Model Accuracy:", accuracy_score(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

"""Evaluating the model"""

# Import necessary functions from sklearn.metrics
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, classification_report

# Calculate evaluation metrics
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average='weighted') # For multi-class
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')


# Print the results
print("Accuracy:", accuracy)
print("Precision:", precision)
print("Recall:", recall)
print("F1 Score:", f1)

"""Grid Search for KNN

This cell performs Grid Search with cross-validation to find the best hyperparameters for the KNN classifier.
"""

# Define the parameter grid for Grid Search
param_grid = {'n_neighbors': [3, 5, 7, 9]}

# Perform Grid Search with Cross-Validation
grid_search = GridSearchCV(KNeighborsClassifier(), param_grid, cv=5)
grid_search.fit(X_train, y_train)

# Display the best parameters and cross-validation score
print("Best parameters from Grid Search:", grid_search.best_params_)
print("Best cross-validation score:", grid_search.best_score_)

# Use the best estimator from grid search for final predictions
best_knn = grid_search.best_estimator_
y_pred_best = best_knn.predict(X_test)

# Evaluate the optimized model
print("Optimized KNN Model Accuracy:", accuracy_score(y_test, y_pred_best))
print("Classification Report:\n", classification_report(y_test, y_pred_best))

"""Classifying a New Image

This cell defines a function classify_new_image to classify a new image using the trained KNN model.
"""

from sklearn.metrics import pairwise_distances

def classify_new_image(image_path, model, scaler, X_train, y_train):
    # Extract features from the new image
    feature = extract_color_features(image_path)
    if feature is None:
        return "Image not readable or no feature extracted."

    # Standardize the feature based on the training data
    feature_scaled = scaler.transform([feature])

    # Make prediction using the KNN model
    prediction = model.predict(feature_scaled)[0]

    # Find the nearest image in the training set
    distances = pairwise_distances(X_train, feature_scaled)
    nearest_index = distances.argmin()  # Get the index of the nearest neighbor
    nearest_image_label = y_train[nearest_index]  # Get the label of the nearest image

    return prediction, nearest_image_label

# Example usage
new_image_path = '/content/Apple.jpeg'
# Assuming 'knn' or 'best_knn' is your trained KNN model
# Replace 'knn' with 'best_knn' if you want to use the model from GridSearchCV
result, nearest_label = classify_new_image(new_image_path, knn, scaler, X_train, y_train)
print("Prediction for new image:", result)
print("Label of the nearest image in the dataset:", nearest_label)

"""Finding Nearest Image in Dataset

This cell defines a function classify_new_image to predict the class of a new image and also find the nearest image in the dataset using KNN with distance metrics.
"""

def preprocess_images(image_dir, labels_dir):
    features = []
    labels = []
    image_paths = []  # New list to store image paths

    for img_name in os.listdir(image_dir):
        img_path = os.path.join(image_dir, img_name)
        label_path = os.path.join(labels_dir, os.path.splitext(img_name)[0] + '.txt')

        if img_name.endswith(('.png', '.jpg', '.jpeg')) and os.path.exists(label_path):
            feature = extract_color_features(img_path)
            if feature is not None:
                features.append(feature)
                image_paths.append(img_path)  # Add image path
                with open(label_path, 'r') as f:
                    label = f.read().strip()
                labels.append(label)
        else:
            print(f"Skipped file or missing label: {img_name}")

    features = np.array(features)
    labels = np.array(labels)
    return features, labels, image_paths

"""Finding Nearest Image with Feature Extraction

This cell refines the previous process of finding the nearest image with modified preprocessing to extract features and paths.
"""

from scipy.spatial import distance

def find_nearest_image(new_image_path, features, image_paths, scaler):
    # Extract and standardize the feature of the new image
    new_feature = extract_color_features(new_image_path)
    if new_feature is None:
        return "Image not readable or no feature extracted."
    new_feature = scaler.transform([new_feature])

    # Reshape new_feature to 1-D array
    new_feature = new_feature.reshape(-1)

    # Calculate distances from the new feature to all dataset features
    min_distance = float('inf')
    nearest_image_path = None
    for feature, img_path in zip(features, image_paths):
        # Reshape feature to 1-D array if necessary
        feature = feature.reshape(-1) if feature.ndim > 1 else feature
        dist = distance.euclidean(new_feature, feature)
        if dist < min_distance:
            min_distance = dist
            nearest_image_path = img_path

    return nearest_image_path

"""Find Nearest Image: Improved Distance Calculation

This cell improves the previous logic to find the nearest image by explicitly handling the shape of feature vectors when calculating the distance.
"""

# Load the features, labels, and image paths
X, y, image_paths = preprocess_images(train_images_path, train_labels_path)

# Standardize the features
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Define a new image path you want to find the nearest match for
new_image_path = '/content/Apple.jpeg'

# Find the nearest image in the dataset
nearest_image_path = find_nearest_image(new_image_path, X, image_paths, scaler)
print("Nearest image path:", nearest_image_path)

"""Displaying Images

This cell defines a function display_images to display the new image and its nearest neighbor in the dataset side by side.
"""

import matplotlib.pyplot as plt
import cv2
import os

def display_images(new_image_path, nearest_image_path):
    # Check if the nearest image path is valid before proceeding
    if nearest_image_path is None or nearest_image_path.startswith("Image not"):
        print(f"Error: {nearest_image_path}")
        return  # Exit the function early

    # Load the new image and the nearest image
    # Add error handling for cv2.imread
    new_image = cv2.imread(new_image_path)
    nearest_image = cv2.imread(nearest_image_path)

    if new_image is None:
        print(f"Error: Could not read image at path: {new_image_path}")
        return
    if nearest_image is None:
        print(f"Error: Could not read image at path: {nearest_image_path}")
        return

    new_image = cv2.cvtColor(new_image, cv2.COLOR_BGR2RGB)
    nearest_image = cv2.cvtColor(nearest_image, cv2.COLOR_BGR2RGB)

    # Display the images side by side
    plt.figure(figsize=(10, 5))

    # Display the new image
    plt.subplot(1, 2, 1)
    plt.imshow(new_image)
    plt.title("New Image")
    plt.axis("off")

    # Display the nearest image from the dataset
    plt.subplot(1, 2, 2)
    plt.imshow(nearest_image)
    plt.title("Nearest Image in Dataset")
    plt.axis("off")

    plt.show()

# Assuming you have X, image_paths, and scaler from previous code
# new_image_path should be a valid path to an image
# new_image_path = '/path/to/new/image.jpg' #  Replace with a valid path!
new_image_path = '/content/Apple.jpeg'


# Find the nearest image in the dataset
nearest_image_path = find_nearest_image(new_image_path, X, image_paths, scaler)
print("Nearest image path:", nearest_image_path)

# Display the new image and the nearest match
display_images(new_image_path, nearest_image_path)

"""Dominant Color Extraction

This cell defines functions to extract the dominant color of an image and display information about it.
"""

def get_dominant_color(image_path):
    # Load the image
    img = cv2.imread(image_path)
    if img is None:
        print(f"Image not found or unreadable at path: {image_path}")
        return None
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # Calculate the mean color
    mean_color = cv2.mean(img)[:3]  # Average color as (R, G, B)
    return mean_color

def display_color_info(image_path, title="Image"):
    # Get the dominant color
    dominant_color = get_dominant_color(image_path)
    if dominant_color is None:
        return

    # Display the image and its dominant color
    img = cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB)
    color_patch = np.ones((100, 100, 3), dtype=np.uint8) * np.uint8(dominant_color)

    plt.figure(figsize=(8, 4))

    # Display the image
    plt.subplot(1, 2, 1)
    plt.imshow(img)
    plt.title(title)
    plt.axis("off")

    # Display the color patch
    plt.subplot(1, 2, 2)
    plt.imshow(color_patch)
    plt.title(f"Dominant Color: RGB {dominant_color}")
    plt.axis("off")

    plt.show()

    # Example Usage
new_image_path = '/content/Banana-Single.jpg'

# Find the nearest image in the dataset
nearest_image_path = find_nearest_image(new_image_path, X, image_paths, scaler)
print("Nearest image path:", nearest_image_path)

# Display the new image, nearest match, and their dominant colors
print("New Image:")
display_color_info(new_image_path, title="New Image")

print("Nearest Image in Dataset:")
display_color_info(nearest_image_path, title="Nearest Image in Dataset")